---
import BaseLayout from "../layouts/BaseLayout.astro";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
export const prerender = true;

// Load glossary data from public folder
// Using fs for prerender (build time) - path resolved relative to project root
const DATA_URL = "/data/glossary_export.json";
let filteredGlossary: any[] = [];
let loadError: string | null = null;

try {
  // Resolve path: find public folder relative to current file location
  // Convert file:// URL to file system path (works cross-platform)
  const currentFile = fileURLToPath(import.meta.url);
  const currentDir = path.dirname(currentFile);
  
  // Try multiple path resolutions
  const possiblePaths = [
    // From src/pages/glossary.astro -> astro-site/public/data/glossary_export.json
    path.resolve(currentDir, "../../../public/data/glossary_export.json"),
    // From workspace root
    path.join(process.cwd(), "astro-site", "public", "data", "glossary_export.json"),
    // From astro-site directory
    path.join(process.cwd(), "public", "data", "glossary_export.json"),
  ];
  
  let glossaryPath: string | null = null;
  for (const tryPath of possiblePaths) {
    if (fs.existsSync(tryPath)) {
      glossaryPath = tryPath;
      break;
    }
  }
  
  if (!glossaryPath) {
    throw new Error(`Glossary file not found. Tried paths: ${possiblePaths.join(", ")}`);
  }
  
  const glossaryFile = fs.readFileSync(glossaryPath, "utf-8");
  const glossaryData = JSON.parse(glossaryFile);
  const glossaryArray = Array.isArray(glossaryData) ? glossaryData : (glossaryData?.Glossary ?? []);

  // Filter to only category 1 and active entries
  filteredGlossary = glossaryArray
    .filter((item: any) => item.Active === 1 && item.Glossary_CatID_FK === 1)
    .map((item: any) => {
      // Resolve image path
      let imagePath = "";
      if (item.image) {
        const img = String(item.image).trim().replace(/\\/g, "/");
        if (img.startsWith("/images/glossary/")) {
          imagePath = img;
        } else if (img.startsWith("/images/")) {
          imagePath = img.replace("/images/", "/images/glossary/");
        } else if (img) {
          imagePath = `/images/glossary/${img.replace(/^\.?\//, "")}`;
        }
      }

      // Create slug from English term
      const slug = String(item.English || "")
        .toLowerCase()
        .trim()
        .replace(/&/g, "and")
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/(^-|-$)/g, "");

      return {
        id: item.GlossaryId,
        term: String(item.English || "").trim(),
        slug,
        description: String(item.Helpinfo || "").trim(),
        image: imagePath,
      };
    })
    .filter((item: any) => item.term.length > 0)
    .sort((a: any, b: any) => a.term.localeCompare(b.term, "en"));
} catch (error: any) {
  console.error("Error loading glossary data:", error);
  loadError = error?.message || String(error) || "Unknown error";
}

// Serialize for client-side use
const glossaryJson = JSON.stringify(filteredGlossary);
const errorMessage = loadError ? `Failed to load glossary data from ${DATA_URL}: ${loadError}` : null;
---

<BaseLayout title="Glossary | Knit by Machine" description="Machine knitting glossary with definitions and explanations">
  <div class="glossary-page">
    {errorMessage && (
      <div class="glossary-error" role="alert">
        <p>{errorMessage}</p>
      </div>
    )}
    <!-- Sticky Search Bar -->
    <div class="glossary-sticky-header">
      <div class="glossary-search-wrapper">
        <input 
          type="search" 
          id="glossary-search" 
          class="glossary-search" 
          placeholder="Find a term‚Ä¶" 
          autocomplete="off"
          aria-label="Search glossary terms"
        />
      </div>

      <!-- Sticky Alphabet Jump Bar -->
      <div class="glossary-alphabet" id="glossary-alphabet" aria-label="Jump to letter">
        <!-- Will be populated by JavaScript -->
      </div>
    </div>

    <!-- Terms List -->
    <div class="glossary-list" id="glossary-list" role="list">
      <!-- Will be populated by JavaScript -->
    </div>

    <!-- Empty State -->
    <div class="glossary-empty" id="glossary-empty" style="display: none;">
      <p>No matches found. Try a different search term.</p>
    </div>
  </div>
</BaseLayout>

<style>
  .glossary-page {
    max-width: 100%;
    margin: 0 auto;
    padding: 0;
    background: #f7f7f7;
    min-height: 100vh;
  }

  /* Error Message */
  .glossary-error {
    background: #fee;
    border: 1px solid #fcc;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem;
    color: #c33;
    font-size: 0.9rem;
  }

  .glossary-error p {
    margin: 0;
  }

  /* Sticky Header Container */
  .glossary-sticky-header {
    position: sticky;
    top: 0;
    z-index: 100;
    background: #f7f7f7;
    padding: 1rem 1rem 0.5rem;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08);
  }

  /* Search Bar */
  .glossary-search-wrapper {
    margin-bottom: 0.75rem;
    position: relative;
  }

  .glossary-search-wrapper::before {
    content: "üîç";
    position: absolute;
    left: 1rem;
    top: 50%;
    transform: translateY(-50%);
    font-size: 1rem;
    pointer-events: none;
    z-index: 1;
    opacity: 0.5;
  }

  .glossary-search {
    width: 100%;
    padding: 0.75rem 1rem 0.75rem 2.75rem;
    font-size: 1rem;
    border: 1px solid rgba(0, 0, 0, 0.15);
    border-radius: 999px;
    outline: none;
    background: #fff;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }

  .glossary-search::placeholder {
    color: rgba(0, 0, 0, 0.5);
  }

  .glossary-search:focus {
    border-color: rgba(0, 0, 0, 0.25);
    box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
  }

  /* Alphabet Bar */
  .glossary-alphabet {
    display: flex;
    gap: 0.5rem;
    overflow-x: auto;
    overflow-y: hidden;
    padding: 0.5rem 0;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    white-space: nowrap;
  }

  .glossary-alphabet::-webkit-scrollbar {
    display: none;
  }

  .glossary-alphabet button {
    flex: 0 0 auto;
    min-width: 44px;
    height: 44px;
    padding: 0 0.875rem;
    font-size: 0.9rem;
    font-weight: 600;
    color: rgba(0, 0, 0, 0.7);
    background: rgba(0, 0, 0, 0.06);
    border: 1px solid rgba(0, 0, 0, 0.12);
    border-radius: 999px;
    cursor: pointer;
    transition: all 0.15s ease;
    touch-action: manipulation;
  }

  .glossary-alphabet button:active:not(:disabled) {
    background: rgba(0, 0, 0, 0.1);
    transform: scale(0.95);
  }

  .glossary-alphabet button:disabled {
    opacity: 0.25;
    cursor: not-allowed;
  }

  /* Terms List */
  .glossary-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
  }

  .glossary-item {
    background: #fff;
    border: 1px solid rgba(0, 0, 0, 0.12);
    border-radius: 12px;
    overflow: hidden;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    cursor: pointer;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
  }

  .glossary-item:active {
    transform: scale(0.98);
  }

  .glossary-item.expanded {
    border-color: rgba(0, 0, 0, 0.2);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
  }

  /* Collapsed Row */
  .glossary-item-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem;
    gap: 1rem;
  }

  .glossary-item-title {
    flex: 1;
    font-size: 1rem;
    font-weight: 700;
    color: #1a1a1a;
    margin: 0;
    text-align: left;
    line-height: 1.4;
  }

  .glossary-item-thumb {
    flex: 0 0 auto;
    width: 100px;
    height: 100px;
    border-radius: 12px;
    object-fit: cover;
    background: rgba(0, 0, 0, 0.05);
    border: 1px solid rgba(0, 0, 0, 0.1);
  }

  .glossary-item-thumb[src=""],
  .glossary-item-thumb:not([src]) {
    display: none;
  }

  /* Expanded Content */
  .glossary-item-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .glossary-item.expanded .glossary-item-content {
    max-height: 5000px;
  }

  .glossary-item-body {
    padding: 0;
  }

  .glossary-item-image-wrapper {
    width: 100%;
    background: #f9f9f9;
    padding: 1rem;
    margin-bottom: 0;
  }

  .glossary-item-image {
    width: 100%;
    max-height: 350px;
    object-fit: contain;
    border-radius: 8px;
    display: block;
  }

  .glossary-item-image[src=""],
  .glossary-item-image:not([src]) {
    display: none;
  }

  .glossary-item-description {
    padding: 20px;
    font-size: 0.95rem;
    line-height: 1.7;
    color: rgba(0, 0, 0, 0.85);
  }

  .glossary-item-description :global(p) {
    margin: 0 0 1rem;
  }

  .glossary-item-description :global(p:last-child) {
    margin-bottom: 0;
  }

  /* Empty State */
  .glossary-empty {
    text-align: center;
    padding: 3rem 1.5rem;
    color: rgba(0, 0, 0, 0.5);
    font-size: 1rem;
  }

  /* Ensure search doesn't zoom on iOS */
  @media (max-width: 640px) {
    .glossary-search {
      font-size: 16px; /* Prevents zoom on iOS */
    }
  }

  /* Desktop adjustments */
  @media (min-width: 641px) {
    .glossary-page {
      max-width: 700px;
    }

    .glossary-sticky-header {
      padding: 1.5rem 1.5rem 0.75rem;
    }

    .glossary-list {
      padding: 1.5rem;
    }
  }
</style>

<script define:vars={{ glossaryJson }}>
  (() => {
    const elSearch = document.getElementById("glossary-search");
    const elAlphabet = document.getElementById("glossary-alphabet");
    const elList = document.getElementById("glossary-list");
    const elEmpty = document.getElementById("glossary-empty");

    // Parse glossary data from Astro
    const allTerms = JSON.parse(glossaryJson);
    let filteredTerms = [...allTerms];
    let expandedSlug = null;

    // Get first letter of term
    function firstLetter(term) {
      const t = (term || "").trim();
      if (!t) return "#";
      const c = t[0].toUpperCase();
      return (c >= "A" && c <= "Z") ? c : "#";
    }

    // Get hash from URL
    function getHashSlug() {
      const h = (location.hash || "").replace(/^#/, "").trim();
      return h || null;
    }

    // Set hash in URL
    function setHash(slug) {
      if (!slug) {
        history.replaceState(null, "", window.location.pathname);
        return;
      }
      history.replaceState(null, "", "#" + slug);
    }

    // Build alphabet bar
    function buildAlphabetBar() {
      if (!elAlphabet) return;
      elAlphabet.innerHTML = "";
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
      const availableLetters = new Set(
        filteredTerms.map(t => firstLetter(t.term)).filter(L => L !== "#")
      );

      for (const L of letters) {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = L;
        btn.disabled = !availableLetters.has(L);
        btn.addEventListener("click", () => jumpToLetter(L));
        elAlphabet.appendChild(btn);
      }
    }

    // Jump to first term starting with letter
    function jumpToLetter(letter) {
      const firstTerm = filteredTerms.find(t => firstLetter(t.term) === letter);
      if (firstTerm) {
        expandTerm(firstTerm.slug, true);
      }
    }

    // Expand/collapse term
    function expandTerm(slug, scrollIntoView = false) {
      if (!elList) return;
      
      // Close previously expanded term
      if (expandedSlug && expandedSlug !== slug) {
        const prevItem = elList.querySelector(`[data-slug="${CSS.escape(expandedSlug)}"]`);
        if (prevItem) prevItem.classList.remove("expanded");
      }

      // Toggle current term
      const item = elList.querySelector(`[data-slug="${CSS.escape(slug)}"]`);
      if (!item) return;

      const wasExpanded = item.classList.contains("expanded");
      
      if (wasExpanded) {
        item.classList.remove("expanded");
        expandedSlug = null;
        setHash(null);
      } else {
        item.classList.add("expanded");
        expandedSlug = slug;
        setHash(slug);
        
        if (scrollIntoView) {
          setTimeout(() => {
            item.scrollIntoView({ behavior: "smooth", block: "nearest" });
          }, 100);
        }
      }
    }

    // Render terms list
    function renderList() {
      if (!elList || !elEmpty) return;
      
      elList.innerHTML = "";
      elEmpty.style.display = filteredTerms.length === 0 ? "block" : "none";

      if (filteredTerms.length === 0) return;

      buildAlphabetBar();

      for (const term of filteredTerms) {
        const item = document.createElement("div");
        item.className = "glossary-item";
        item.dataset.slug = term.slug;
        if (expandedSlug === term.slug) {
          item.classList.add("expanded");
        }

        // Header (collapsed view)
        const header = document.createElement("div");
        header.className = "glossary-item-header";
        
        const title = document.createElement("h3");
        title.className = "glossary-item-title";
        title.textContent = term.term;
        
        const thumb = document.createElement("img");
        thumb.className = "glossary-item-thumb";
        thumb.alt = term.term;
        thumb.loading = "lazy";
        if (term.image) {
          thumb.src = term.image;
          thumb.onerror = () => { thumb.style.display = "none"; };
        } else {
          thumb.style.display = "none";
        }

        header.appendChild(title);
        header.appendChild(thumb);

        // Content (expanded view)
        const content = document.createElement("div");
        content.className = "glossary-item-content";
        
        const body = document.createElement("div");
        body.className = "glossary-item-body";

        if (term.image) {
          const imageWrapper = document.createElement("div");
          imageWrapper.className = "glossary-item-image-wrapper";
          
          const img = document.createElement("img");
          img.className = "glossary-item-image";
          img.alt = term.term;
          img.loading = "lazy";
          img.src = term.image;
          img.onerror = () => { imageWrapper.style.display = "none"; };
          
          imageWrapper.appendChild(img);
          body.appendChild(imageWrapper);
        }

        if (term.description) {
          const desc = document.createElement("div");
          desc.className = "glossary-item-description";
          desc.innerHTML = term.description;
          body.appendChild(desc);
        }

        content.appendChild(body);

        // Click handler
        item.addEventListener("click", () => {
          expandTerm(term.slug, true);
        });

        item.appendChild(header);
        item.appendChild(content);
        elList.appendChild(item);
      }
    }

    // Filter terms
    function applyFilter() {
      const query = (elSearch?.value || "").trim().toLowerCase();
      
      if (!query) {
        filteredTerms = [...allTerms];
      } else {
        filteredTerms = allTerms.filter(t => {
          const termLower = (t.term || "").toLowerCase();
          return termLower.includes(query);
        });
      }

      // If current expanded term is not in filtered results, close it
      if (expandedSlug && !filteredTerms.some(t => t.slug === expandedSlug)) {
        expandedSlug = null;
      }

      renderList();
    }

    // Initialize
    function init() {
      // Check for hash in URL
      const hashSlug = getHashSlug();
      if (hashSlug && allTerms.some(t => t.slug === hashSlug)) {
        expandedSlug = hashSlug;
      }

      renderList();

      // Expand term from hash after render
      if (expandedSlug && elList) {
        const slugToScroll = expandedSlug;
        setTimeout(() => {
          if (elList) {
            const item = elList.querySelector(`[data-slug="${CSS.escape(slugToScroll)}"]`);
            if (item) {
              item.scrollIntoView({ behavior: "smooth", block: "nearest" });
            }
          }
        }, 300);
      }
    }

    // Event listeners
    elSearch?.addEventListener("input", () => applyFilter());
    
    window.addEventListener("hashchange", () => {
      const hashSlug = getHashSlug();
      if (hashSlug && allTerms.some(t => t.slug === hashSlug)) {
        expandTerm(hashSlug, true);
      } else if (!hashSlug && expandedSlug) {
        // Close current expanded term
        if (elList) {
          const item = elList.querySelector(`[data-slug="${CSS.escape(expandedSlug)}"]`);
          if (item) {
            item.classList.remove("expanded");
            expandedSlug = null;
            setHash(null);
          }
        }
      }
    });

    // Initialize on load
    init();
  })();
</script>

---
import Layout from "../../layouts/layout.astro";
import glossaryRaw from "../../data/glossary.json";
import { slugify } from "../../lib/slugify";

export const prerender = true;

// Normalize + filter (adjust these filters if needed)
const filteredGlossary = (Array.isArray(glossaryRaw) ? glossaryRaw : (glossaryRaw?.Glossary ?? []))
  .filter((item: any) => (item.Active ?? 1) === 1)
  // If you still need category filtering, uncomment:
  // .filter((item: any) => item.Glossary_CatID_FK === 1)
  .map((item: any) => {
    // Image normalization (keep if your JSON has "image")
    let imagePath = "";
if (item.image) {
  const img = String(item.image).trim().replace(/\\/g, "/");

  // If it's already a full URL, keep it
  if (img.startsWith("http://") || img.startsWith("https://")) {
    imagePath = img;
  } else if (img.startsWith("/images/")) {
    imagePath = img;
  } else if (img) {
    imagePath = `/images/glossary/${img.replace(/^\.?\//, "")}`;
  }
}


    const term = String(item.English ?? item.english ?? "").trim();
    const slug = slugify(term);

    return {
      id: item.GlossaryId ?? item.id ?? slug,
      term,
      slug,
      description: String(item.Helpinfo ?? item.helpinfo ?? item.description ?? "").trim(),
      image: imagePath,
    };
  })
  .filter((t: any) => t.term.length > 0)
  .sort((a: any, b: any) => a.term.localeCompare(b.term, "en"));

const glossaryJson = JSON.stringify(filteredGlossary);
---

<Layout>
  <main class="glossary-page">
    <header class="glossary-hero">
      <h1>Glossary</h1>
      <p class="lead">
        A quick reference for machine knitters ‚Äî definitions, examples, and helpful context.
      </p>
      <p class="note">
        Free access. Login required (email only).
      </p>
    </header>

    <!-- Sticky Search Bar + Alphabet -->
    <div class="glossary-sticky-header" data-glossary-lockable>
      <div class="glossary-search-wrapper">
        <input
          type="search"
          id="glossary-search"
          class="glossary-search"
          placeholder="Find a term‚Ä¶"
          autocomplete="off"
          aria-label="Search glossary terms"
          disabled
        />
      </div>

      <div class="glossary-alphabet" id="glossary-alphabet" aria-label="Jump to letter">
        <!-- populated by JS -->
      </div>
    </div>

    <!-- Terms List -->
    <div class="glossary-list" id="glossary-list" role="list" data-glossary-lockable>
      <!-- populated by JS -->
    </div>

    <!-- Empty State -->
    <div class="glossary-empty" id="glossary-empty" style="display: none;">
      <p>No matches found. Try a different search term.</p>
    </div>

    <!-- Lock overlay -->
    <aside class="lock" id="glossaryLock" aria-live="polite">
      <div class="lock-box">
        <h3>Free access ‚Äî login required</h3>
        <p>
          To use the glossary (A‚ÄìZ and search), please log in.
          If you‚Äôre new, create free access with your email.
        </p>
        <div class="lock-actions">
          <a class="btn" href="/login">Log in / Create free access</a>
        </div>
      </div>
    </aside>
  </main>

  <!-- Memberstack lock/unlock -->
  <script is:inline>
    (async function () {
      const lock = document.getElementById("glossaryLock");
      const lockables = document.querySelectorAll("[data-glossary-lockable]");
      const search = document.getElementById("glossary-search");

      function setLocked(isLocked) {
        if (isLocked) {
          lock?.classList.remove("is-hidden");
          lockables.forEach((el) => el.classList.add("is-locked"));
          if (search) search.disabled = true;
        } else {
          lock?.classList.add("is-hidden");
          lockables.forEach((el) => el.classList.remove("is-locked"));
          if (search) search.disabled = false;
        }
      }

      setLocked(true);

      try {
        if (!window.$memberstackDom) return;
        const { data: member } = await window.$memberstackDom.getCurrentMember();
        if (member) setLocked(false);
      } catch (e) {
        setLocked(true);
      }
    })();
  </script>

  <!-- Your existing client-side glossary logic -->
  <script define:vars={{ glossaryJson }}>
    (() => {
      const elSearch = document.getElementById("glossary-search");
      const elAlphabet = document.getElementById("glossary-alphabet");
      const elList = document.getElementById("glossary-list");
      const elEmpty = document.getElementById("glossary-empty");

      const allTerms = JSON.parse(glossaryJson);
      let filteredTerms = [...allTerms];
      let expandedSlug = null;

      function firstLetter(term) {
        const t = (term || "").trim();
        if (!t) return "#";
        const c = t[0].toUpperCase();
        return (c >= "A" && c <= "Z") ? c : "#";
      }

      function getHashSlug() {
        const h = (location.hash || "").replace(/^#/, "").trim();
        return h || null;
      }

      function setHash(slug) {
        if (!slug) {
          history.replaceState(null, "", window.location.pathname);
          return;
        }
        history.replaceState(null, "", "#" + slug);
      }

      function buildAlphabetBar() {
        if (!elAlphabet) return;
        elAlphabet.innerHTML = "";
        const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
        const availableLetters = new Set(
          filteredTerms.map(t => firstLetter(t.term)).filter(L => L !== "#")
        );

        for (const L of letters) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.textContent = L;
          btn.disabled = !availableLetters.has(L);
          btn.addEventListener("click", () => jumpToLetter(L));
          elAlphabet.appendChild(btn);
        }
      }

      function jumpToLetter(letter) {
        const firstTerm = filteredTerms.find(t => firstLetter(t.term) === letter);
        if (firstTerm) expandTerm(firstTerm.slug, true);
      }

      function expandTerm(slug, scrollIntoView = false) {
        if (!elList) return;

        if (expandedSlug && expandedSlug !== slug) {
          const prevItem = elList.querySelector(`[data-slug="${CSS.escape(expandedSlug)}"]`);
          if (prevItem) prevItem.classList.remove("expanded");
        }

        const item = elList.querySelector(`[data-slug="${CSS.escape(slug)}"]`);
        if (!item) return;

        const wasExpanded = item.classList.contains("expanded");

        if (wasExpanded) {
          item.classList.remove("expanded");
          expandedSlug = null;
          setHash(null);
        } else {
          item.classList.add("expanded");
          expandedSlug = slug;
          setHash(slug);

          if (scrollIntoView) {
            setTimeout(() => item.scrollIntoView({ behavior: "smooth", block: "nearest" }), 100);
          }
        }
      }

      function renderList() {
        if (!elList || !elEmpty) return;

        elList.innerHTML = "";
        elEmpty.style.display = filteredTerms.length === 0 ? "block" : "none";
        if (filteredTerms.length === 0) return;

        buildAlphabetBar();

        for (const term of filteredTerms) {
          const item = document.createElement("div");
          item.className = "glossary-item";
          item.dataset.slug = term.slug;
          if (expandedSlug === term.slug) item.classList.add("expanded");

          const header = document.createElement("div");
          header.className = "glossary-item-header";

          const title = document.createElement("h3");
          title.className = "glossary-item-title";
          title.textContent = term.term;

          const thumb = document.createElement("img");
          thumb.className = "glossary-item-thumb";
          thumb.alt = term.term;
          thumb.loading = "lazy";
          if (term.image) {
            thumb.src = term.image;
            thumb.onerror = () => { thumb.style.display = "none"; };
          } else {
            thumb.style.display = "none";
          }

          header.appendChild(title);
          header.appendChild(thumb);

          const content = document.createElement("div");
          content.className = "glossary-item-content";

          const body = document.createElement("div");
          body.className = "glossary-item-body";

          if (term.image) {
            const imageWrapper = document.createElement("div");
            imageWrapper.className = "glossary-item-image-wrapper";

            const img = document.createElement("img");
            img.className = "glossary-item-image";
            img.alt = term.term;
            img.loading = "lazy";
            img.src = term.image;
            img.onerror = () => { imageWrapper.style.display = "none"; };

            imageWrapper.appendChild(img);
            body.appendChild(imageWrapper);
          }

          if (term.description) {
            const desc = document.createElement("div");
            desc.className = "glossary-item-description";
            desc.innerHTML = term.description;
            body.appendChild(desc);
          }

          content.appendChild(body);

          item.addEventListener("click", () => expandTerm(term.slug, true));

          item.appendChild(header);
          item.appendChild(content);
          elList.appendChild(item);
        }
      }

      function applyFilter() {
        const query = (elSearch?.value || "").trim().toLowerCase();

        if (!query) {
          filteredTerms = [...allTerms];
        } else {
          filteredTerms = allTerms.filter(t => (t.term || "").toLowerCase().includes(query));
        }

        if (expandedSlug && !filteredTerms.some(t => t.slug === expandedSlug)) {
          expandedSlug = null;
        }

        renderList();
      }

      function init() {
        const hashSlug = getHashSlug();
        if (hashSlug && allTerms.some(t => t.slug === hashSlug)) expandedSlug = hashSlug;

        renderList();

        if (expandedSlug && elList) {
          const slugToScroll = expandedSlug;
          setTimeout(() => {
            const item = elList.querySelector(`[data-slug="${CSS.escape(slugToScroll)}"]`);
            if (item) item.scrollIntoView({ behavior: "smooth", block: "nearest" });
          }, 300);
        }
      }

      elSearch?.addEventListener("input", applyFilter);

      window.addEventListener("hashchange", () => {
        const hashSlug = getHashSlug();
        if (hashSlug && allTerms.some(t => t.slug === hashSlug)) {
          expandTerm(hashSlug, true);
        }
      });

      init();
    })();
  </script>

  <style>
    /* layout + overlay */
    .glossary-page { max-width: 100%; margin: 0 auto; padding: 0; background: #f7f7f7; min-height: 100vh; position: relative; }
    .glossary-hero { max-width: 700px; margin: 0 auto; padding: 2rem 1rem 0.5rem; }
    .glossary-hero h1 { margin: 0 0 .4rem; font-size: 2.2rem; }
    .lead { margin: 0 0 .5rem; opacity: .85; }
    .note { margin: 0; opacity: .7; }

    .is-locked { filter: blur(1.4px); opacity: .55; pointer-events: none; user-select: none; }
    .lock { position: absolute; inset: 0; display: grid; place-items: center; padding: 1rem; }
    .lock.is-hidden { display: none; }
    .lock-box { max-width: 560px; width: 100%; padding: 1.1rem; border-radius: 18px; border: 1px solid rgba(0,0,0,.10); background: rgba(255,255,255,.92); box-shadow: 0 12px 30px rgba(0,0,0,.08); }
    .lock-actions { margin-top: .8rem; }
    .btn { display: inline-block; padding: .65rem .9rem; border-radius: 14px; text-decoration: none; border: 1px solid rgba(0,0,0,.12); }

    /* your existing UI styles (mostly unchanged) */
    .glossary-sticky-header { position: sticky; top: 0; z-index: 100; background: #f7f7f7; padding: 1rem 1rem 0.5rem; border-bottom: 1px solid rgba(0, 0, 0, 0.08); }
    .glossary-search-wrapper { margin-bottom: 0.75rem; position: relative; }
    .glossary-search-wrapper::before { content: "üîç"; position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); font-size: 1rem; pointer-events: none; z-index: 1; opacity: 0.5; }
    .glossary-search { width: 100%; padding: 0.75rem 1rem 0.75rem 2.75rem; font-size: 1rem; border: 1px solid rgba(0, 0, 0, 0.15); border-radius: 999px; outline: none; background: #fff; }
    .glossary-alphabet { display: flex; gap: 0.5rem; overflow-x: auto; padding: 0.5rem 0; -webkit-overflow-scrolling: touch; scrollbar-width: none; white-space: nowrap; }
    .glossary-alphabet::-webkit-scrollbar { display: none; }
    .glossary-alphabet button { flex: 0 0 auto; min-width: 44px; height: 44px; padding: 0 0.875rem; font-size: 0.9rem; font-weight: 600; background: rgba(0, 0, 0, 0.06); border: 1px solid rgba(0, 0, 0, 0.12); border-radius: 999px; cursor: pointer; }
    .glossary-alphabet button:disabled { opacity: 0.25; cursor: not-allowed; }

    .glossary-list { display: flex; flex-direction: column; gap: 0.5rem; padding: 1rem; max-width: 700px; margin: 0 auto; }
    .glossary-item { background: #fff; border: 1px solid rgba(0, 0, 0, 0.12); border-radius: 12px; overflow: hidden; cursor: pointer; }
    .glossary-item-header { display: flex; align-items: center; justify-content: space-between; padding: 1rem; gap: 1rem; }
    .glossary-item-title { flex: 1; font-size: 1rem; font-weight: 700; margin: 0; }
    .glossary-item-thumb { width: 100px; height: 100px; border-radius: 12px; object-fit: cover; }
    .glossary-item-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease; }
    .glossary-item.expanded .glossary-item-content { max-height: 5000px; }
    .glossary-item-image-wrapper { width: 100%; background: #f9f9f9; padding: 1rem; }
    .glossary-item-image { width: 100%; max-height: 350px; object-fit: contain; border-radius: 8px; display: block; }
    .glossary-item-description { padding: 20px; font-size: 0.95rem; line-height: 1.7; opacity: .9; }
    .glossary-empty { text-align: center; padding: 3rem 1.5rem; opacity: .6; }
  </style>
</Layout>
